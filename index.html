<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schafkopf Abrechnung Pro</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/recharts@2.5.0/dist/Recharts.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .min-h-screen { min-height: 100vh; }
        .bg-gradient-to-br { background: linear-gradient(to bottom right, var(--tw-gradient-stops)); }
        .from-slate-900 { --tw-gradient-from: #0f172a; --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(15, 23, 42, 0)); }
        .via-green-900 { --tw-gradient-stops: var(--tw-gradient-from), #14532d, var(--tw-gradient-to, rgba(20, 83, 45, 0)); }
        .to-slate-900 { --tw-gradient-to: #0f172a; }
        .bg-gradient-to-r { background: linear-gradient(to right, var(--tw-gradient-stops)); }
        .from-green-600 { --tw-gradient-from: #16a34a; --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(22, 163, 74, 0)); }
        .to-green-700 { --tw-gradient-to: #15803d; }
        .from-red-600 { --tw-gradient-from: #dc2626; --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(220, 38, 38, 0)); }
        .p-4 { padding: 1rem; }
        .p-6 { padding: 1.5rem; }
        .p-8 { padding: 2rem; }
        .max-w-7xl { max-width: 80rem; margin-left: auto; margin-right: auto; }
        .space-y-6 > * + * { margin-top: 1.5rem; }
        .grid { display: grid; }
        .rounded-2xl { border-radius: 1rem; }
        .rounded-xl { border-radius: 0.75rem; }
        .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
        .text-white { color: #fff; }
        .text-green-400 { color: #4ade80; }
        .bg-white { background-color: #fff; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-2 { gap: 0.5rem; }
        .gap-3 { gap: 0.75rem; }
        .border { border: 1px solid #e5e7eb; }
        .w-full { width: 100%; }
        .h-80 { height: 20rem; }
        input { outline: none; border: 1px solid #e5e7eb; padding: 0.5rem 1rem; border-radius: 0.75rem; }
        button { cursor: pointer; border: none; transition: all 0.2s; }
        button:active { transform: scale(0.95); }
        @media (min-width: 1024px) { .lg\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); } .lg\:col-span-2 { grid-column: span 2 / span 2; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;
        const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = Recharts;

        // Icons
        const Users = () => <span style={{fontSize: '1.2rem'}}>üë•</span>;
        const Plus = () => <span>+</span>;
        const Minus = () => <span>‚àí</span>;
        const Trophy = () => <span>üèÜ</span>;
        const Zap = () => <span>‚ö°</span>;
        const BarChart3 = () => <span>üìä</span>;

        window.storage = {
            get: async (key) => ({ value: localStorage.getItem(key) }),
            set: async (key, value) => localStorage.setItem(key, value),
            delete: async (key) => localStorage.removeItem(key)
        };

        function SchafkopfApp() {
            const [players, setPlayers] = useState([]);
            const [newPlayerName, setNewPlayerName] = useState('');
            const [selectedWinners, setSelectedWinners] = useState([]);
            const [selectedLosers, setSelectedLosers] = useState([]);
            const [gameHistory, setGameHistory] = useState([]);
            const [pointValue, setPointValue] = useState('');
            const [gameMode, setGameMode] = useState('normal');

            const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];

            useEffect(() => {
                const loadData = async () => {
                    const playersData = await window.storage.get('schafkopf_players');
                    const historyData = await window.storage.get('schafkopf_history');
                    if (playersData?.value) setPlayers(JSON.parse(playersData.value));
                    if (historyData?.value) setGameHistory(JSON.parse(historyData.value));
                };
                loadData();
            }, []);

            const saveData = (newPlayers, newHistory) => {
                window.storage.set('schafkopf_players', JSON.stringify(newPlayers));
                window.storage.set('schafkopf_history', JSON.stringify(newHistory));
            };

            const addPlayer = () => {
                if (newPlayerName.trim() && players.length < 6) {
                    const currentRound = gameHistory.length;
                    const newPlayers = [...players, { 
                        name: newPlayerName.trim(), 
                        points: 0,
                        handsPlayed: 0,
                        history: [{ round: currentRound, points: 0 }]
                    }];
                    setPlayers(newPlayers);
                    setNewPlayerName('');
                    saveData(newPlayers, gameHistory);
                }
            };

            const toggleWinner = (index) => {
                if (selectedLosers.includes(index)) return;
                const max = gameMode === 'solo' ? 3 : 2;
                if (selectedWinners.includes(index)) setSelectedWinners(selectedWinners.filter(i => i !== index));
                else if (selectedWinners.length < max) setSelectedWinners([...selectedWinners, index]);
            };

            const toggleLoser = (index) => {
                if (selectedWinners.includes(index)) return;
                const max = gameMode === 'solo' ? 1 : 2;
                if (selectedLosers.includes(index)) setSelectedLosers(selectedLosers.filter(i => i !== index));
                else if (selectedLosers.length < max) setSelectedLosers([...selectedLosers, index]);
            };

            const recordGame = () => {
                const points = parseFloat(pointValue);
                if (isNaN(points) || points <= 0 || selectedWinners.length < 1) {
                    alert('Checke Eingabe & Auswahl!');
                    return;
                }
                const newPlayers = [...players];
                const currentRound = gameHistory.length + 1;

                selectedWinners.forEach(i => {
                    newPlayers[i].points += points;
                    newPlayers[i].handsPlayed += 1;
                    newPlayers[i].history.push({ round: currentRound, points: newPlayers[i].points });
                });
                selectedLosers.forEach(i => {
                    newPlayers[i].points -= points;
                    newPlayers[i].handsPlayed += 1;
                    newPlayers[i].history.push({ round: currentRound, points: newPlayers[i].points });
                });
                // History f√ºr Aussetzende
                players.forEach((_, i) => {
                    if (!selectedWinners.includes(i) && !selectedLosers.includes(i)) {
                        newPlayers[i].history.push({ round: currentRound, points: newPlayers[i].points });
                    }
                });

                const game = {
                    timestamp: new Date().toLocaleTimeString('de-DE', {hour: '2-digit', minute:'2-digit'}),
                    winners: selectedWinners.map(i => players[i].name),
                    losers: selectedLosers.map(i => players[i].name),
                    sitting: players.map((p, i) => !selectedWinners.includes(i) && !selectedLosers.includes(i) ? p.name : null).filter(Boolean),
                    points: points,
                    mode: gameMode,
                    round: currentRound
                };

                const newHistory = [...gameHistory, game];
                setPlayers(newPlayers);
                setGameHistory(newHistory);
                setSelectedWinners([]);
                setSelectedLosers([]);
                setPointValue('');
                saveData(newPlayers, newHistory);
            };

            const deleteGame = (index) => {
                if (!confirm('Runde l√∂schen?')) return;
                const actualIdx = gameHistory.length - 1 - index;
                const game = gameHistory[actualIdx];
                const newPlayers = players.map(p => {
                    let pPoints = p.points;
                    let pHands = p.handsPlayed;
                    if (game.winners.includes(p.name)) { pPoints -= game.points; pHands--; }
                    if (game.losers.includes(p.name)) { pPoints += game.points; pHands--; }
                    return { ...p, points: pPoints, handsPlayed: Math.max(0, pHands), history: p.history.filter(h => h.round !== game.round) };
                });
                const newHistory = gameHistory.filter((_, i) => i !== actualIdx);
                setPlayers(newPlayers);
                setGameHistory(newHistory);
                saveData(newPlayers, newHistory);
            };

            const getChartData = () => {
                return Array.from({ length: gameHistory.length + 1 }, (_, r) => {
                    const entry = { name: r };
                    players.forEach(p => {
                        const h = p.history.find(x => x.round === r) || p.history.filter(x => x.round < r).pop() || {points: 0};
                        entry[p.name] = h.points;
                    });
                    return entry;
                });
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-green-900 to-slate-900 p-4 md:p-8">
                    <div className="max-w-7xl mx-auto space-y-6">
                        
                        {/* Header */}
                        <div className="flex justify-between items-center bg-white/10 p-6 rounded-2xl border border-white/20 shadow-2xl">
                            <h1 className="text-2xl md:text-4xl font-black text-white flex items-center gap-3">
                                <Zap /> Schafkopf <span className="text-green-400">Pro</span>
                            </h1>
                            <button onClick={() => {if(confirm('Alles l√∂schen?')){localStorage.clear(); location.reload();}}} className="bg-red-600/20 text-white p-2 rounded-xl border border-red-500/50"><Minus /></button>
                        </div>

                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                            <div className="space-y-6">
                                {/* Spieler-Input */}
                                <div className="bg-white rounded-2xl p-6 shadow-xl">
                                    <h2 className="font-bold mb-4 flex items-center gap-2"><Users /> Spieler ({players.length}/6)</h2>
                                    <div className="flex gap-2 mb-4">
                                        <input className="w-full" value={newPlayerName} onChange={e => setNewPlayerName(e.target.value)} placeholder="Name..." />
                                        <button onClick={addPlayer} className="bg-green-600 text-white px-4 rounded-xl"><Plus /></button>
                                    </div>
                                    <div className="flex flex-wrap gap-2">
                                        {players.map((p, i) => <span key={i} className="bg-gray-100 px-3 py-1 rounded-full text-sm font-bold">{p.name}</span>)}
                                    </div>
                                </div>

                                {/* Eingabe-Maske */}
                                <div className="bg-white rounded-2xl p-6 shadow-xl">
                                    <h2 className="font-bold mb-4 flex items-center gap-2"><Trophy /> Neues Spiel</h2>
                                    <div className="grid grid-cols-2 gap-2 mb-4">
                                        <button onClick={() => setGameMode('normal')} className={`py-2 rounded-xl font-bold ${gameMode === 'normal' ? 'bg-green-600 text-white' : 'bg-gray-100'}`}>Normal</button>
                                        <button onClick={() => setGameMode('solo')} className={`py-2 rounded-xl font-bold ${gameMode === 'solo' ? 'bg-purple-600 text-white' : 'bg-gray-100'}`}>Solo</button>
                                    </div>
                                    <div className="space-y-4">
                                        <p className="text-xs font-bold text-gray-400">GEWINNER:</p>
                                        <div className="flex flex-wrap gap-2">
                                            {players.map((p, i) => (
                                                <button key={i} onClick={() => toggleWinner(i)} className={`px-3 py-2 rounded-xl border-2 ${selectedWinners.includes(i) ? 'border-green-500 bg-green-50' : 'border-gray-100'}`}>{p.name}</button>
                                            ))}
                                        </div>
                                        <p className="text-xs font-bold text-gray-400">VERLIERER:</p>
                                        <div className="flex flex-wrap gap-2">
                                            {players.map((p, i) => (
                                                <button key={i} onClick={() => toggleLoser(i)} className={`px-3 py-2 rounded-xl border-2 ${selectedLosers.includes(i) ? 'border-red-500 bg-red-50' : 'border-gray-100'}`}>{p.name}</button>
                                            ))}
                                        </div>
                                        <input type="number" className="w-full text-lg font-bold" value={pointValue} onChange={e => setPointValue(e.target.value)} placeholder="Betrag in ct..." />
                                        <button onClick={recordGame} className="w-full bg-green-600 text-white py-3 rounded-xl font-black shadow-lg">EINTRAGEN</button>
                                    </div>
                                </div>
                            </div>

                            {/* Dashboard & Chart */}
                            <div className="lg:col-span-2 space-y-6">
                                <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                                    {[...players].sort((a,b) => b.points - a.points).map((p, i) => (
                                        <div key={i} className="bg-white p-4 rounded-2xl shadow-md border-b-4 border-green-500">
                                            <p className="text-xs text-gray-400">Rang {i+1}</p>
                                            <h3 className="font-bold truncate">{p.name}</h3>
                                            <p className={`text-xl font-black ${p.points >= 0 ? 'text-green-600' : 'text-red-600'}`}>{(p.points/100).toFixed(2)}‚Ç¨</p>
                                        </div>
                                    ))}
                                </div>

                                <div className="bg-white p-6 rounded-2xl shadow-xl">
                                    <h2 className="font-bold mb-4 flex items-center gap-2"><BarChart3 /> Verlauf</h2>
                                    <div className="h-80 w-full">
                                        <ResponsiveContainer>
                                            <LineChart data={getChartData()}>
                                                <CartesianGrid strokeDasharray="3 3" vertical={false} />
                                                <XAxis dataKey="name" hide />
                                                <YAxis />
                                                <Tooltip formatter={(v) => [(v/100).toFixed(2)+'‚Ç¨']} />
                                                <Legend />
                                                {players.map((p, i) => <Line key={p.name} type="monotone" dataKey={p.name} stroke={colors[i % colors.length]} strokeWidth={3} dot={false} />)}
                                            </LineChart>
                                        </ResponsiveContainer>
                                    </div>
                                </div>

                                <div className="bg-white rounded-2xl shadow-xl overflow-hidden">
                                    <div className="p-4 bg-gray-50 border-b font-bold">Historie</div>
                                    <div className="max-h-60 overflow-y-auto">
                                        {[...gameHistory].reverse().map((g, i) => (
                                            <div key={i} className="p-4 border-b flex justify-between items-center text-sm">
                                                <span><strong>{g.winners.join(', ')}</strong> schlugen {g.losers.join(', ')} ({(g.points/100).toFixed(2)}‚Ç¨)</span>
                                                <button onClick={() => deleteGame(i)} className="text-red-500 font-bold">L√∂schen</button>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SchafkopfApp />);
    </script>
</body>
</html>
